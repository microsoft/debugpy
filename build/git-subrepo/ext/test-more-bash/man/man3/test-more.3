.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test::More 1"
.TH Test::More 1 "January 2016" "Generated by Swim v0.1.41" "\s-1TAP\s0 Testing for Bash"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
Test::More \- \s-1TAP\s0 Testing for Bash
.SH "Synopsis"
.IX Header "Synopsis"
Write a test file like this. Maybe call it \f(CW\*(C`test/test.t\*(C'\fR:
.PP
.Vb 1
\&    #!/usr/bin/env bash
\&
\&    TEST_MORE_PATH="/path/to/test\-more\-bash"
\&    BASHLIB="\`
\&        find $TEST_MORE_PATH \-type d |
\&        grep \-E \*(Aq/(bin|lib)$\*(Aq |
\&        xargs \-n1 printf "%s:"\`"
\&    PATH="$BASHLIB$PATH"
\&
\&    source bash+ :std
\&
\&    use Test::More
\&
\&    plan tests 8
\&
\&    some\-command
\&    ok $? \*(Aqsome\-command is ok\*(Aq
\&
\&    # or:
\&    ok "\`some\-command\`" \*(Aqsome\-command is ok\*(Aq
\&
\&    pass \*(AqThis will always pass\*(Aq
\&
\&    fail \*(AqThis will always fail\*(Aq
\&
\&    is \`echo foo\` \*(Aqfoo\*(Aq \*(Aqfoo is foo\*(Aq
\&
\&    isnt foo bar "foo isn\*(Aqt bar"
\&
\&    like food foo \*(Aqfood is like foo\*(Aq
\&
\&    unlike team I "There\*(Aqs no \*(AqI\*(Aq in \*(Aqteam\*(Aq"
\&
\&    diag "A message for stderr"
\&
\&    note "A message for stdout"
.Ve
.PP
Run the test with \f(CW\*(C`prove\*(C'\fR like this:
.PP
.Vb 1
\&    prove test/test.t
.Ve
.PP
Prove knows it's Bash from the first line (the hashbang), and it just works.
.SH "Description"
.IX Header "Description"
Test::More is the tried and true testing library for Perl. It uses \s-1TAP \s0(the Test Anything Protocol). This is the same thing for Bash.  For the most part it should work exactly the same.
.SH "Methods"
.IX Header "Methods"
This is the basic usage:
.IP "\(bu" 4
\&\f(CW\*(C`plan tests $count\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`ok $status_code "$label"\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`pass "$label"\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`fail "$label"\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`is "$got" "$want" "label"\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`isnt "$got" "$unwanted" "$label"\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`like "$got" "$regex" "$label"\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`unlike "$got" "$regex" "$label"\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`diag "$message"\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`note "$message"\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`done_testing $count\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`plan skip_all "$reason"\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`BAIL_OUT "$reason"\*(C'\fR
.PP
More detailed info coming soon.
.SH "Author"
.IX Header "Author"
Ingy döt Net <ingy@bpan.org>
.SH "Copyright & License"
.IX Header "Copyright & License"
Copyright 2013\-2016. Ingy döt Net.
.PP
The \s-1MIT\s0 License (\s-1MIT\s0)
